{% load static %}
<script>

    /* Constants & Initialization for the entire Overlay */
    const root = document.querySelector(":root");
    const body = document.querySelector("body");
    const header = document.querySelector("header");
    const main = document.querySelector("main");

    const checkmark = document.getElementById("check-mark-animation");
    const overlay = document.querySelector("#overlay");
    const cursor = document.querySelector('#cursor-base');
    const cursorImage = document.querySelector('#cursor-image');
    const tooltip = document.querySelector('#tooltip');

    const imgCursorRegular = '/static/icons/cursor/cursor-regular.svg';
    const imgCursorLink = '/static/icons/cursor/cursor-link.svg';
    const imgCursorText = '/static/icons/cursor/cursor-text.svg';

    /* Wait for the user to have moved the mouse again before showing it, since it will be at x0,y0 when reloading. */
    /* There doesn't seem to be a way to detect the real mouse position outside of an event. */
    cursor.style.display = "none";

    /* Set the height of the entire overlay to the size of the document. This is needed for the cursor to be visible. */
    overlay.style.height = `${body.clientHeight + 70}px`;

    /* Users can disable this custom cursor in their settings, so we need to wrap everything in this. */
    if ('{{request.session.use_custom_cursor}}' != 'False'){
        /* Reposition the cursor according to the mouse position */
        const updateCursorPosition = (e)=> {
            let mouseX = e.clientX
            let mouseY = e.clientY + root.scrollTop

            root.style.backgroundPositionX = e.clientX*-.01 + "px";
            root.style.backgroundPositionY = e.clientY*-.01 + "px";

            cursor.style.display = "block";
            cursor.style.transform = `translate3d(${mouseX}px, ${mouseY}px, 0)`;
            tooltip.style.transform = `translate3d(calc(${mouseX}px + 30px), calc(${mouseY}px + 30px), 0)`;
        }
        window.addEventListener("mousemove", updateCursorPosition);
        window.addEventListener("scroll", updateCursorPosition);

        const change_cursor_appearance = (img, x, y)=> {
            cursorImage.setAttribute('href', img);
            cursorImage.setAttribute('x', `${x}`);
            cursorImage.setAttribute('y', `${y}`);
        }

        /* Change the appearance of the cursor depending on the element you're hovering at. */
        /* Add here any more elements that require special cursors. */
        const link_selectors = 'a, button, select, option, input[type="checkbox"], .rd-day-body, .dropdown-toggle';
        const text_selectors = 'textarea:enabled, input[type="text"]:enabled, input[type="password"]:enabled, input[type="search"]:enabled';
        const special_selectors = link_selectors + ", " + text_selectors

        /* Behavior for links, buttons, etc. */
        $(link_selectors).on("mouseover", function() {change_cursor_appearance(imgCursorLink, 0, 0);});
        $(link_selectors).on("mouseup", function() {change_cursor_appearance(imgCursorLink, 0, 0);});
        $(link_selectors).on("mousedown", function() {change_cursor_appearance(imgCursorRegular, 0, 0);});

        /* Behavior for all text areas */
        $(text_selectors).on("mouseover", function() {change_cursor_appearance(imgCursorText, -20, -16);});

        /* Default/Fallback cursor */
        $(special_selectors).on("mouseleave", function() {change_cursor_appearance(imgCursorRegular, 0, 0);});
    }

    /* Tooltip detection */
    function updateTooltips(){
        $(".tooltip-source").on("mouseover", function() {
            let text = $(this).attr('data-tooltip-context')

            if (text && text != "" 
                && screenTransition.style.backgroundColor == "rgba(0, 0, 0, 0)" 
                && cursor.style.display != "none"){
                tooltip.style.display = "block";

                let context = $(this).attr('data-tooltip-context')
                let content = $(this).attr('data-tooltip-content')
                tooltip.innerHTML = context;
                if (content){tooltip.innerHTML += `\r\n${content}`;}
            }
            else {
                tooltip.style.display = "none";
            }
        });
    }
    updateTooltips()

    addEventListener("mouseout", (event) => {tooltip.style.display = "none";})

    /* Date&Time display */
    const dateTimeDisplay = document.getElementById("datetime-display");

    if (dateTimeDisplay){
        async function update_time(){
            time = new Date();
            document.getElementById("datetime-display")
            .textContent = time.toLocaleString('default', { weekday: "long", year: "numeric", month: "long", day: "numeric", })
            + ' ' + time.toLocaleTimeString();
        }

        update_time()
        setInterval(update_time, 1000);
    }

    /* Only proceed if a translation JSON was loaded beforehand;*/
    /*'locale_json' has been defined in 'site_js_preload.html' already */
    function applyLocaleToPage(){
        $.getJSON('/static/localization/{{request.session.lang_code}}/main.json', 
        function(json_data){})
        .done(function(json_data) {
            Object.entries(json_data).forEach(function(entry) {
                /* Each entry would normally be a Key/Value pair in JSON. */
                let key = entry[0]; let text = entry[1];
                let elements = document.querySelectorAll("#" + key);

                /* Determine the HTML value based on the element type. */
                elements.forEach(function(element) {
                    switch (element.localName) {
                        case "textarea":
                        case "input":
                            /* 'placeholder' refers to the intangible text inside the textarea/input field. */
                            element.placeholder = text; break;
                        case "select":
                            /* Select elements require access to their 'option' children. */
                            /* When translating them, make sure to place all options inside of a list.*/
                            let children = element.children;
                            for (let i = 0; i < children.length; i++) {
                                children[i].textContent = text[i]}
                            break;
                        case "datalist":
                            element.innerHTML = ""
                            if (typeof text[0] == "string") {
                                text.forEach(function(option) {
                                    element.insertAdjacentHTML( 'beforeend', `<option value="${option}"></option>`)});
                            }
                            else {
                                text.forEach(function(option) {
                                    element.insertAdjacentHTML( 'beforeend', `<option value="${option[0]}">${option[0]} (${option[1]})</option>`)
                                });
                            }
                            break;
                        default:
                            element.textContent = text; break;
                    }
                });
            });
        })
    }
    applyLocaleToPage()

    /* Load and apply localized text specific to the Tooltips. */
    function applyLocaleToTooltips(){
        $.getJSON('/static/localization/{{request.session.lang_code}}/tooltip.json', 
        function(json_data){})
        .done(function(json_data) {
            Object.entries(json_data).forEach(function(entry) {
                /* Each entry would normally be a Key/Value pair in JSON. */
                let key = entry[0]; let text = entry[1];
                let elements = document.querySelectorAll("#" + key);

                elements.forEach(function(element) {
                    element.className += " tooltip-source"
                    element.setAttribute("data-tooltip-context", text);
                });
            });
        })
    }
    applyLocaleToTooltips();
    
    function getLocaleText(key = "", default_text = ""){
        if (locale_json[key])
            return locale_json[key];
        else
            return default_text;
    }

    /* Chane Language Button behaviors */
    $(".language-btn").on( "click", function() {
        let lang_code = $(this).attr('value');

        $.ajax({ 
            type: 'POST', url: '{% url "core:session_change_language" %}',
            data: { action: 'post',
                lang_code: lang_code,
                csrfmiddlewaretoken: '{{ csrf_token }}'},
            success: function(json) { location.reload(); },
            error: function(xhr, errmsg, err) { console.log(errmsg); }
        });
    });

    /* Since it is enabled on boot, disable it after a short time. */
    $( document ).ready(function() {
        setTimeout(function(){
            disableLoadingScreen()}, 40 + (Math.random() * 100)
        );
    });

    /* Close Alerts after five seconds */
    let alerts = document.querySelectorAll('.alert:not(.alert-info)');
    setTimeout(function() {
        alerts.forEach(function(alert) {
            let bsAlert = new bootstrap.Alert(alert);
            bsAlert.close(); // removes element from DOM
        });
    }, 5000);

    /* Check current URL and disable all links to it */
    /* This is primarily done to reduce requests when, for example, constantly heading to the profile page. */
    let currentURL = window.location.href;
    document.querySelectorAll("a").forEach(function(element) {
        if (element.href == currentURL)
        element.style = "pointer-events: none; color: gray;";
    });

    /* Prevent resubmissions */
    if ( window.history.replaceState ) {
        window.history.replaceState( null, null, window.location.href );
    }

    function playCheckmarkAnimation() {
        checkmark.style.display = "block";
        checkmark.style.opacity = 1;

        setTimeout(function(){
            checkmark.style.opacity = 0;
        }, 2000);

        setTimeout(function(){
            checkmark.style.display = "none";
        }, 3600);
    }

    function playConfetti(origin = 0.55) {
        setTimeout(function () {
            var count = 200;
            var new_shape = confetti.shapeFromPath({ path: 'M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z' });
            var defaults = { origin: { y: origin }, shapes: [new_shape], gravity: 1.133 };

            function fire(particleRatio, opts) {
                confetti({ ...defaults, ...opts, particleCount: Math.floor(count * particleRatio) });
            }
            fire(0.25, { spread: 26, startVelocity: 55, zIndex: 2000, });
            fire(0.2, { spread: 60, zIndex: 2000, scalar: 1.2 });
            fire(0.35, { spread: 100, decay: 0.91, scalar: 0.8, zIndex: 2000});
            fire(0.1, { spread: 120, startVelocity: 25, scalar: 1.2, decay: 0.92, scalar: 1.2, zIndex: 2000 });
            fire(0.1, { spread: 120, startVelocity: 45, scalar: 1.2, zIndex: 2000});
        }, 1);
    }

</script>